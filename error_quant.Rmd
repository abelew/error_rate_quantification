---
title: "Counting RT mutations from illumina sequencing data."
author: "atb abelew@gmail.com"
date: "`r Sys.Date()`"
output:
  html_document:
    code_download: true
    code_folding: show
    fig_caption: true
    fig_height: 7
    fig_width: 7
    highlight: tango
    keep_md: false
    mode: selfcontained
    number_sections: true
    self_contained: true
    theme: readable
    toc: true
    toc_float:
      collapsed: false
      smooth_scroll: false
  rmdformats::readthedown:
    code_download: true
    code_folding: show
    df_print: paged
    fig_caption: true
    fig_height: 7
    fig_width: 7
    highlight: tango
    width: 300
    keep_md: false
    mode: selfcontained
    toc_float: true
  BiocStyle::html_document:
    code_download: true
    code_folding: show
    fig_caption: true
    fig_height: 7
    fig_width: 7
    highlight: tango
    keep_md: false
    mode: selfcontained
    toc_float: true
---

<style type="text/css">
body, td {
  font-size: 16px;
}
code.r{
  font-size: 16px;
}
pre {
 font-size: 16px
}
</style>

```{r options, include=FALSE}
library("hpgltools")
tt <- devtools::load_all("/data/hpgltools")
knitr::opts_knit$set(width=120,
                     progress=TRUE,
                     verbose=TRUE,
                     echo=TRUE)
knitr::opts_chunk$set(error=TRUE,
                      dpi=96)
old_options <- options(digits=4,
                       stringsAsFactors=FALSE,
                       knitr.duplicate.label="allow")
ggplot2::theme_set(ggplot2::theme_bw(base_size=10))
rundate <- format(Sys.Date(), format="%Y%m%d")
previous_file <- "index.Rmd"
ver <- "20200314"

##tmp <- sm(loadme(filename=paste0(gsub(pattern="\\.Rmd", replace="", x=previous_file), "-v", ver, ".rda.xz")))
rmd_file <- "error_quant.Rmd"
```

# Calculating error rates.

I wrote the function 'create_matrices()' to collect mutation counts.  At least
in theory the results from it should be able to address most/any question
regarding the counts of mutations observed in the data.

## Categorize the data with at least 3 indexes per mutant

```{r triples}
devtools::load_all("Rerrrt")
sample_sheet <- "sample_sheets/all_samples.xlsx"
ident_column <- "identtable"
mut_column <- "mutationtable"
min_reads <- 3
min_indexes <- 3
min_sequencer <- 10
min_position <- 24
max_position <- 176
max_mutations_per_read <- NULL
prune_n <- TRUE
verbose <- TRUE
excel <- glue::glue("excel/{rundate}_triples-v{ver}.xlsx")
triples <- create_matrices(sample_sheet=sample_sheet,
                           ident_column=ident_column, mut_column=mut_column,
                           min_reads=min_reads, min_indexes=min_indexes,
                           min_sequencer=min_sequencer,
                           min_position=min_position, max_position=max_position,
                           prune_n=prune_n, verbose=verbose, excel=excel)

max_mutations_per_read <- 10
excel <- glue::glue("excel/{rundate}_triples_tenmpr-v{ver}.xlsx")
triples_tenmpr <- create_matrices(sample_sheet=sample_sheet,
                                  ident_column=ident_column, mut_column=mut_column,
                                  min_reads=min_reads, min_indexes=min_indexes,
                                  min_sequencer=min_sequencer,
                                  min_position=min_position, max_position=max_position,
                                  prune_n=prune_n, verbose=verbose, excel=excel)
max_mutations_per_read <- 5
excel <- glue::glue("excel/{rundate}_triples_fivempr-v{ver}.xlsx")
triples_fivempr <- create_matrices(sample_sheet=sample_sheet,
                                   ident_column=ident_column, mut_column=mut_column,
                                   min_reads=min_reads, min_indexes=min_indexes,
                                   min_sequencer=min_sequencer,
                                   min_position=min_position, max_position=max_position,
                                   prune_n=prune_n, verbose=verbose, excel=excel)
```

## Categorize the data with at least 5 indexes per mutant

```{r quints}
min_indexes <- 5
max_mutations_per_read <- NULL
excel <- glue::glue("excel/{rundate}_quints-v{ver}.xlsx")
quints <- create_matrices(sample_sheet=sample_sheet,
                          ident_column=ident_column, mut_column=mut_column,
                          min_reads=min_reads, min_indexes=min_indexes,
                          min_sequencer=min_sequencer,
                          min_position=min_position, max_position=max_position,
                          prune_n=prune_n, verbose=verbose, excel=excel)
max_mutations_per_read <- 10
excel <- glue::glue("excel/{rundate}_quints_tenmpr-v{ver}.xlsx")
quints_tenmpr <- create_matrices(sample_sheet=sample_sheet,
                                 ident_column=ident_column, mut_column=mut_column,
                                 min_reads=min_reads, min_indexes=min_indexes,
                                 min_sequencer=min_sequencer,
                                 min_position=min_position, max_position=max_position,
                                 prune_n=prune_n, verbose=verbose, excel=excel)
max_mutations_per_read <- 5
excel <- glue::glue("excel/{rundate}_quints_fivempr-v{ver}.xlsx")
quints_fivempr <- create_matrices(sample_sheet=sample_sheet,
                                  ident_column=ident_column, mut_column=mut_column,
                                  min_reads=min_reads, min_indexes=min_indexes,
                                  min_sequencer=min_sequencer,
                                  min_position=min_position, max_position=max_position,
                                  prune_n=prune_n, verbose=verbose, excel=excel)
```

# Questions from Dr. DeStefano

I think what is best is to get the number of recovered mutations of each type
from each data set.  That would be A to T, A to G, A to C; T to A, T to G, T to
C; G to A, G to C, G to T; and C to A, C to G, C to T; as well as deletions and
insertions.  I would then need the sum number of the reads that met all our
criteria (i.e. at least 3 good recovered reads for that 14 nt index).  Each set
of 3 or more would ct as "1" read of that particular index so I would need the
total with this in mind.  I also need to know the total number of nucleotides
that were in the region we decided to consider in the analysis.  We may want to
try this for 3 or more and 5 or more recovered indexes if it is not hard.  This
information does not include specific positions on the template where errors
occurred but we can look at that latter.  Right now I just want to get a general
error rate and type of error.  It would basically be calculated by dividing the
number of recovered mutations of a particular type by sum number of the reads
times the number of nucleotides screened in the template.  As it ends up, this
number does not really have a lot of meaning but it can be used to calculate the
overall mutation rate as well as the rate for transversions, transitions, and
deletions and insertions.

# Answers

In order to address those queries, I invoked create_matrices() with a minimum
index count of 3 and 5.  It should be noted that this is not the same as
requiring 3 or 5 reads per index.  In both cases I require 3 reads per index.

## Recovered mutations of each type

I am interpreting this question as the number of indexes recovered for each
mutation type.  I collect this information in 2 ways of interest: the indexes by
type which are deemed to be from the RT and from the sequencer.  In addition, I
calculate a normalized (cpm) version of this information which may be used to look for
changes across samples.

### Mutations by RT index

This following block should print out tables of the numbers of mutant indexes
observed for each type for the RT and the sequencer.  One would hope that the
sequencer will be consistent for all samples, but I think the results will
instead suggest that my metric is not yet stringent enough.

```{r mutation_index_count, results='asis'}
knitr::kable(triples[["matrices"]][["miss_indexes_by_type"]])
knitr::kable(triples_tenmpr[["matrices"]][["miss_indexes_by_type"]])
knitr::kable(triples_fivempr[["matrices"]][["miss_indexes_by_type"]])
knitr::kable(quints[["matrices"]][["miss_indexes_by_type"]])
knitr::kable(quints_tenmpr[["matrices"]][["miss_indexes_by_type"]])
knitr::kable(quints_fivempr[["matrices"]][["miss_indexes_by_type"]])

knitr::kable(triples[["matrices"]][["miss_sequencer_by_type"]])
knitr::kable(triples_tenmpr[["matrices"]][["miss_sequencer_by_type"]])
knitr::kable(triples_fivempr[["matrices"]][["miss_sequencer_by_type"]])
knitr::kable(quints[["matrices"]][["miss_sequencer_by_type"]])
knitr::kable(quints_tenmpr[["matrices"]][["miss_sequencer_by_type"]])
knitr::kable(quints_fivempr[["matrices"]][["miss_sequencer_by_type"]])
```

Plots of this information

```{r mutation_index_count_plots}
triples[["plots"]][["counts"]][["miss_indexes_by_type"]]
triples_tenmpr[["plots"]][["counts"]][["miss_indexes_by_type"]]
triples_fivempr[["plots"]][["counts"]][["miss_indexes_by_type"]]

quints[["plots"]][["counts"]][["miss_indexes_by_type"]]
quints_tenmpr[["plots"]][["counts"]][["miss_indexes_by_type"]]
quints_fivempr[["plots"]][["counts"]][["miss_indexes_by_type"]]
```

This suggests to me that this information needs to be normalized in some more
sensible fashion.  Thus the following:

### Mutations by RT index, post normalization

The same numbers may be expressed in the context of the number of indexes
observed / sample and/or as a cpm across samples.  Thus in the first instance
one can look at the apparent error rate for each sample, and in the second
instance one may look for relative changes in apparent error rate across
samples.

#### Rewriting the matrices as cpm to account for library sizes.

```{r mutation_index_normalized, results='asis'}
knitr::kable(triples[["normalized"]][["miss_indexes_by_type"]])
knitr::kable(triples_tenmpr[["normalized"]][["miss_indexes_by_type"]])
knitr::kable(triples_fivempr[["normalized"]][["miss_indexes_by_type"]])
knitr::kable(quints[["normalized"]][["miss_indexes_by_type"]])
knitr::kable(quints_tenmpr[["normalized"]][["miss_indexes_by_type"]])
knitr::kable(quints_fivempr[["normalized"]][["miss_indexes_by_type"]])

knitr::kable(triples[["normalized"]][["miss_sequencer_by_type"]])
knitr::kable(triples_tenmpr[["normalized"]][["miss_sequencer_by_type"]])
knitr::kable(triples_fivempr[["normalized"]][["miss_sequencer_by_type"]])
knitr::kable(quints[["normalized"]][["miss_sequencer_by_type"]])
knitr::kable(quints_tenmpr[["normalized"]][["miss_sequencer_by_type"]])
knitr::kable(quints_fivempr[["normalized"]][["miss_sequencer_by_type"]])
```

#### Rewriting the matrices by dividing by all indexes

This I think starts to address the later text in your query.

```{r mutation_index_normalized_by_counts, results='asis'}
knitr::kable(triples[["matrices_by_counts"]][["miss_indexes_by_type"]])
knitr::kable(quints[["matrices_by_counts"]][["miss_indexes_by_type"]])

knitr::kable(triples[["matrices_by_counts"]][["miss_sequencer_by_type"]])
knitr::kable(quints[["matrices_by_counts"]][["miss_sequencer_by_type"]])
```

#### Rewriting the matrices by dividing by all indexes and cpm

I think this might prove to be where we get the most meaningful results.

The nicest thing in it is that after accounting for library sizes and total
indexes observed, we finally see that the sequencer error is mostly consistent
across all samples and mutation types -- with a couple of notable exceptions.

By the same token, for the mutations which _are_ identical for the sequencer, we
have some which are decidedly different for the non-sequencer data.  The most
notable examples I think are A to G but _not G to A; and C to T.

```{r mutation_index_cpm_by_counts, results='asis'}
knitr::kable(triples[["normalized_by_counts"]][["miss_indexes_by_type"]])
knitr::kable(triples_tenmpr[["normalized_by_counts"]][["miss_indexes_by_type"]])
knitr::kable(triples_fivempr[["normalized_by_counts"]][["miss_indexes_by_type"]])
knitr::kable(quints[["normalized_by_counts"]][["miss_indexes_by_type"]])
knitr::kable(quints_tenmpr[["normalized_by_counts"]][["miss_indexes_by_type"]])
knitr::kable(quints_fivempr[["normalized_by_counts"]][["miss_indexes_by_type"]])

knitr::kable(triples[["normalized_by_counts"]][["miss_sequencer_by_type"]])
knitr::kable(triples_tenmpr[["normalized_by_counts"]][["miss_sequencer_by_type"]])
knitr::kable(triples_fivempr[["normalized_by_counts"]][["miss_sequencer_by_type"]])
knitr::kable(quints[["normalized_by_counts"]][["miss_sequencer_by_type"]])
knitr::kable(quints_tenmpr[["normalized_by_counts"]][["miss_sequencer_by_type"]])
knitr::kable(quints_fivempr[["normalized_by_counts"]][["miss_sequencer_by_type"]])
```

### Indels by RT index

The following blocks will repeat the above, but looking for insertions.
This data does not observe sufficient deletions to make a proper count for them.

```{r insert_index_count, results='asis'}
knitr::kable(triples[["matrices"]][["insert_indexes_by_nt"]])
knitr::kable(triples_tenmpr[["matrices"]][["insert_indexes_by_nt"]])
knitr::kable(triples_fivempr[["matrices"]][["insert_indexes_by_nt"]])
knitr::kable(quints[["matrices"]][["insert_indexes_by_nt"]])
knitr::kable(quints_tenmpr[["matrices"]][["insert_indexes_by_nt"]])
knitr::kable(quints_fivempr[["matrices"]][["insert_indexes_by_nt"]])

knitr::kable(triples[["matrices"]][["insert_sequencer_by_nt"]])
knitr::kable(triples_tenmpr[["matrices"]][["insert_sequencer_by_nt"]])
knitr::kable(triples_fivempr[["matrices"]][["insert_sequencer_by_nt"]])
knitr::kable(quints[["matrices"]][["insert_sequencer_by_nt"]])
knitr::kable(quints_tenmpr[["matrices"]][["insert_sequencer_by_nt"]])
knitr::kable(quints_fivempr[["matrices"]][["insert_sequencer_by_nt"]])
```

Plots of this information

```{r insert_index_count_plots}
triples[["plots"]][["counts"]][["insert_indexes_by_nt"]]
triples_tenmpr[["plots"]][["counts"]][["insert_indexes_by_nt"]]
triples_fivempr[["plots"]][["counts"]][["insert_indexes_by_nt"]]

quints[["plots"]][["counts"]][["insert_indexes_by_nt"]]
quints_tenmpr[["plots"]][["counts"]][["insert_indexes_by_nt"]]
quints_fivempr[["plots"]][["counts"]][["insert_indexes_by_nt"]]
```

### Insertions by RT index, post normalization

#### Rewriting the matrices as cpm to account for library sizes.

```{r insert_index_normalized, results='asis'}
knitr::kable(triples[["normalized"]][["insert_indexes_by_nt"]])
knitr::kable(triples_tenmpr[["normalized"]][["insert_indexes_by_nt"]])
knitr::kable(triples_fivempr[["normalized"]][["insert_indexes_by_nt"]])
knitr::kable(quints[["normalized"]][["insert_indexes_by_nt"]])
knitr::kable(quints_tenmpr[["normalized"]][["insert_indexes_by_nt"]])
knitr::kable(quints_fivempr[["normalized"]][["insert_indexes_by_nt"]])

knitr::kable(triples[["normalized"]][["insert_sequencer_by_nt"]])
knitr::kable(triples_tenmpr[["normalized"]][["insert_sequencer_by_nt"]])
knitr::kable(triples_fivempr[["normalized"]][["insert_sequencer_by_nt"]])
knitr::kable(quints[["normalized"]][["insert_sequencer_by_nt"]])
knitr::kable(quints_tenmpr[["normalized"]][["insert_sequencer_by_nt"]])
knitr::kable(quints_fivempr[["normalized"]][["insert_sequencer_by_nt"]])
```

#### Rewriting the matrices by dividing by all indexes

I think that there are few enough insertion events that this gets a bit messed
up.  I will double check the logic of this, but that is my initial guess given
how few insertions I was seeing when reading the outputs manually.
Unfortunately, this means that for these I also cannot provide a cpm measurement.

```{r insert_index_normalized_by_counts, results='asis'}
knitr::kable(triples[["matrices_by_counts"]][["insert_indexes_by_nt"]])
knitr::kable(triples_tenmpr[["matrices_by_counts"]][["insert_indexes_by_nt"]])
knitr::kable(triples_fivempr[["matrices_by_counts"]][["insert_indexes_by_nt"]])
knitr::kable(quints[["matrices_by_counts"]][["insert_indexes_by_nt"]])
knitr::kable(quints_tenmpr[["matrices_by_counts"]][["insert_indexes_by_nt"]])
knitr::kable(quints_fivempr[["matrices_by_counts"]][["insert_indexes_by_nt"]])

knitr::kable(triples[["matrices_by_counts"]][["insert_sequencer_by_nt"]])
knitr::kable(triples_tenmpr[["matrices_by_counts"]][["insert_sequencer_by_nt"]])
knitr::kable(triples_fivempr[["matrices_by_counts"]][["insert_sequencer_by_nt"]])
knitr::kable(quints[["matrices_by_counts"]][["insert_sequencer_by_nt"]])
knitr::kable(quints_tenmpr[["matrices_by_counts"]][["insert_sequencer_by_nt"]])
knitr::kable(quints_fivempr[["matrices_by_counts"]][["insert_sequencer_by_nt"]])
```

The following is my previous writing of this worksheet which just dumped the
various tables.

# Print raw tables

```{r raw, results='asis'}
for (t in 1:length(triples[["matrices"]])) {
  table_name <- names(triples[["matrices"]])[t]
  message("Raw table: ", table_name, ".")
  print(knitr::kable(triples[["matrices"]][t]))
}
```

# Print raw plots

```{r raw_plots}
for (t in 1:length(triples[["plots"]][["matrices"]])) {
  message("Raw table: ", table_name, ".")
  print(triples[["plots"]][["matrices"]][t])
}
```

# Print normalized tables

```{r norm, results='asis'}
for (t in 1:length(triples[["matrices_counts"]])) {
  table_name <- names(triples[["matrices_counts"]])[t]
  message("Normalized table: ", table_name, ".")
  print(knitr::kable(triples[["matrices_counts"]][t]))
}
```

# Print normalized plots

```{r norm_plots}
for (t in 1:length(triples[["plots"]][["counts"]])) {
  message("Normalized table: ", table_name, ".")
  print(triples[["plots"]][["counts"]][t])
}
```

```{r saveme}
pander::pander(sessionInfo())
message(paste0("This is hpgltools commit: ", get_git_commit()))
this_save <- paste0(gsub(pattern="\\.Rmd", replace="", x=rmd_file), "-v", ver, ".rda.xz")
message(paste0("Saving to ", this_save))
tmp <- sm(saveme(filename=this_save))
```


```{r loadme, eval=FALSE}
loadme(filename=this_save)
```
